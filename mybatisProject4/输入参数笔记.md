# 输入参数：parameterType
1. (接口传入值)类型为 简单类型（8个基本类型+String）  
## \#{}、\${}的区别：  
- a.
    \#{任意值}
    \${value} ，其中的标识符只能是value
- b.
    \#{}自动给String类型加上''  （自动类型转换）
    \${} 原样输出，但是适合于 动态排序（动态字段）

`select stuno,stuname,stuage  from student where stuname = #{value}`

`select stuno,stuname,stuage  from student where stuname = '${value}'`

动态排序：  
`select stuno,stuname,stuage  from student  order by ${value} asc
`

- c.\#{}可以防止SQL注入  
\${}不防止

## \${}、\#{}相同之处：
- a.都可以 获取对象的值 （嵌套类型对象）



## i.获取对象值：
- 模糊查询，方式一：
select stuno,stuname,stuage  from student where stuage= #{stuAge}  or stuname like #{stuName}
Student student = new Student();
student.setStuAge(24);
student.setStuName("%w%");  
List\<Student\> students = studentMapper.queryStudentBystuageOrstuName(student) ;//接口的方法->SQL

- 模糊查询，方式二：
student.setStuName("w");
select stuno,stuname,stuage  from student where stuage= #{stuAge}  or stuname like '%${stuName}%'


## ii.嵌套类型对象



2. (接口传入值)对象类型
\#{属性名}
\${属性名}  
![object#$value](输入参数为对象类型的值.png)




# 输入对象为HashMap：
`where stuage= #{stuAge}`

用map中key的值 匹配 占位符#{stuAge}，如果匹配成功 就用map的value替换占位符


## mybatis调用存储过程
>&lt;select id="queryCountByGradeWithProcedure" statementType="CALLABLE"  parameterType="HashMap" >  
{  
CALL queryCountByGradeWithProcedure(  
&#35;{gName,jdbcType=VARCHAR,mode=IN},  
&#35;{scount,jdbcType=INTEGER,mode=OUT}  
)  
}  
&lt;/select>

其中 通过statementType="CALLABLE"设置SQL的执行方式是存储过程。 存储过程的输入参数gName需要通过HashMap来指定
在使用时，通过hashmap的put方法传入输入参数的值；通过hashmap的Get方法 获取输出参数的值。
要注意Jar问题：ojdbc6.jar不能在 调存储过程时  打回车、tab，但是ojdbc7.jar可以。


如果报错： No enum constant org.apache.ibatis.type.JdbcType.xx，则说明mybatis不支持xx类型，需要查表。

存储过程 无论输入参数是什么值，语法上都需要 用map来传递该值；

只要 是  &lt;transactionManager type="JDBC" />，则增删改都需要手工commit ;


mapper.xml->mapper接口->测试方法
